
import React, { useState } from 'react';
import { leakageData } from '../../data';

const RQ3Tab: React.FC = () => {
  const [isRenamed, setIsRenamed] = useState(false);

  // Original Code (Ground Truth from Defects4J)
  const originalCode = `
public double calculateTotal(Cart cart) {
    double total = 0;
    for (Item item : cart.getItems()) {
        total += item.getPrice(); // Potential bug here
    }
    return total;
}
  `.trim();

  // Renamed Code (Meaningful Alternatives generated by LLM)
  // The logic is identical, but the specific names (keys) are different.
  const renamedCode = `
public double computeAggregateCost(ShoppingBasket basket) {
    double sumValue = 0;
    for (Product product : basket.retrieveProductList()) {
        sumValue += product.fetchUnitCost(); // Potential bug here
    }
    return sumValue;
}
  `.trim();

  return (
    <div className="space-y-12 animate-fade-in">
      {/* Section 1: Visualizer */}
      <section>
        <div className="flex items-center gap-3 mb-6">
           <span className="bg-blue-100 text-blue-800 text-sm font-bold px-3 py-1 rounded-full">Step 1: The Setup</span>
           <h2 className="text-2xl font-bold text-slate-900">Checking for Data Leakage</h2>
        </div>
        <p className="text-slate-600 mb-6 text-lg max-w-4xl">
           Critics might argue: "The LLM only finds the bug because it memorized this specific file (`Cart.java`) from GitHub during training!" 
           To disprove this, the researchers replaced method and variable names with <strong>meaningful synonyms</strong>.
        </p>

        <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
           <div className="flex items-center justify-between mb-4">
              <h3 className="font-bold text-slate-700">Experimental Condition</h3>
              <button 
                onClick={() => setIsRenamed(!isRenamed)}
                className={`px-4 py-2 rounded-lg font-medium transition-colors ${isRenamed ? 'bg-indigo-600 text-white' : 'bg-slate-200 text-slate-700 hover:bg-slate-300'}`}
              >
                {isRenamed ? 'State: Renamed (Synonyms)' : 'State: Original Source'} (Click to Toggle)
              </button>
           </div>

           <div className="relative bg-slate-900 rounded-lg p-6 font-mono text-sm overflow-hidden transition-all min-h-[160px]">
              <div className={`absolute top-0 left-0 w-full h-full p-6 transition-opacity duration-300 ${isRenamed ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                <pre className="text-green-400">{originalCode}</pre>
                <div className="mt-2 text-slate-500">// Original names exactly as they appear in the training data</div>
              </div>
              <div className={`absolute top-0 left-0 w-full h-full p-6 transition-opacity duration-300 ${isRenamed ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                 <pre className="text-indigo-400">{renamedCode}</pre>
                 <div className="mt-2 text-slate-500">// Semantically equivalent, but breaks exact string matching</div>
              </div>
           </div>
           
           <div className="mt-4 text-sm text-slate-600 italic">
              <strong>Why this matters:</strong> If the model was just "remembering" the answer, it would fail when names change. 
              Since it still finds the bug (see results below), it proves the model is <strong>reasoning</strong> about the logic, not just retrieving memory.
           </div>
        </div>
      </section>

      {/* Section 2: Results */}
      <section className="pt-8 border-t border-slate-200">
        <div className="flex items-center gap-3 mb-6">
           <span className="bg-indigo-100 text-indigo-800 text-sm font-bold px-3 py-1 rounded-full">Step 2: The Results</span>
           <h2 className="text-2xl font-bold text-slate-900">It's Not Memorization</h2>
        </div>

        <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200 grid md:grid-cols-2 gap-8">
            <div className="flex flex-col justify-center gap-6">
                {leakageData.map((d, i) => (
                <div key={i} className="space-y-2">
                    <div className="flex justify-between text-sm font-semibold text-slate-700">
                    <span>{d.context}</span>
                    </div>
                    
                    <div className="space-y-1">
                    {/* Original */}
                    <div className="flex items-center gap-3">
                        <div className="w-20 text-xs text-slate-500 text-right">Original</div>
                        <div className="flex-1 bg-slate-100 rounded-full h-6 overflow-hidden relative">
                            <div className="h-full bg-blue-500 absolute top-0 left-0" style={{ width: `${d.original}%` }}></div>
                        </div>
                        <div className="w-12 text-sm font-bold text-slate-700">{d.original}%</div>
                    </div>
                    {/* Renamed */}
                    <div className="flex items-center gap-3">
                        <div className="w-20 text-xs text-slate-500 text-right">Renamed</div>
                        <div className="flex-1 bg-slate-100 rounded-full h-6 overflow-hidden relative">
                            <div className="h-full bg-indigo-500 absolute top-0 left-0" style={{ width: `${d.renamed}%` }}></div>
                        </div>
                        <div className="w-12 text-sm font-bold text-slate-700">{d.renamed}%</div>
                    </div>
                    </div>
                </div>
                ))}
            </div>

            <div className="flex items-center">
                 <div className="bg-green-50 border border-green-200 rounded-lg p-5">
                    <h4 className="font-bold text-green-800 mb-2">Analysis</h4>
                    <p className="text-green-800 text-sm leading-relaxed mb-4">
                        The performance drop between <strong>Original</strong> and <strong>Renamed</strong> code is minimal (~5%).
                    </p>
                    <p className="text-green-800 text-sm leading-relaxed">
                        This confirms that the Order Bias observed in RQ1 is a <strong>fundamental reasoning limitation</strong> of the model architecture, not a side-effect of training data leakage.
                    </p>
                 </div>
            </div>
        </div>
      </section>
    </div>
  );
};

export default RQ3Tab;
